Index: Airfoil.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#On importe la bibliothèque requests pour faire une requête HTTP vers le site AirfoilTools\r\nimport requests\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport csv\r\n\r\n## Class Airfoil va représenter un profil NACA avec ses cordonnées\r\n\r\nclass Airfoil:\r\n\r\n    def __init__(self, nom, coordonnees):\r\n        self.nom = nom # Nom de profil\r\n        self.coordonnees = coordonnees # une liste de tuples (x, y) représentant les points du contour de l’aile\r\n\r\n    \"\"\"\r\n            ----  Fonctions de classe pour exporter un profil du site Airfoil Tools ----\r\n    \"\"\"\r\n    @classmethod\r\n    def depuis_airfoiltools(cls, code_naca: str):\r\n        url = f\"http://airfoiltools.com/airfoil/seligdatfile?airfoil={code_naca.lower()}\"\r\n        reponse = requests.get(url)\r\n\r\n        if reponse.status_code != 200:\r\n            raise Exception(f\"Erreur lors de la récupération du profil NACA {code_naca}\")\r\n\r\n        lignes = reponse.text.strip().splitlines()\r\n        coordonnees = []\r\n\r\n        for ligne in lignes[1:]:  # ignorer la première ligne (titre)\r\n            try:\r\n                parties = ligne.strip().split()\r\n                x = float(parties[0])\r\n                y = float(parties[1])\r\n                coordonnees.append((x, y))\r\n            except (IndexError, ValueError):\r\n                continue  # ignorer les lignes mal formatées\r\n\r\n        return cls(nom=f\"NACA{code_naca}\", coordonnees=coordonnees)\r\n\r\n    # Stocker les coordonnées de Airfoils\r\n    def sauvegarder_coordonnees(self, nom_fichier=\"coordonnees.csv\"):\r\n        with open(nom_fichier, \"w\") as fichier:\r\n            fichier.write(\"x,y\\n\")\r\n            for x, y in self.coordonnees:\r\n                fichier.write(f\"{x},{y}\\n\")\r\n\r\n    # Tracer le contour\r\n    def tracer_contour(self, nom_profil):\r\n        x_vals = [point[0] for point in self.coordonnees]\r\n        y_vals = [point[1] for point in self.coordonnees]\r\n\r\n        plt.figure(figsize=(8, 4))\r\n        plt.plot(x_vals, y_vals, marker='o', linewidth=1)\r\n        plt.title(f\"Profil aérodynamique {nom_profil}\")\r\n        plt.xlabel(\"x\")\r\n        plt.ylabel(\"y\")\r\n        plt.axis(\"equal\")  # pour que l’échelle soit respectée\r\n        plt.grid(True)\r\n        plt.show()\r\n\r\n    \"\"\"\r\n        ----  Fonctions de classe pour tracer un profil (Airfoil) manuellement ----\r\n    \"\"\"\r\n\r\n    # Génération Manuelle d'un Profil\r\n    def naca4_profil(self):\r\n        \"\"\"\r\n        Génère un profil NACA 4 chiffres (Formules issues de Wikipédia)\r\n\r\n        m : cambrure maximale (ex: 0.02 pour 2%)\r\n        p : position de cambrure maximale (ex: 0.4 pour 40%)\r\n        t : épaisseur maximale (ex: 0.12 pour 12%)\r\n        c : corde (longueur, par défaut 1.0)\r\n        n_points : nombre de points (demi-profil)\r\n\r\n        Retourne : arrays x, y_supérieur, y_inférieur\r\n        \"\"\"\r\n        # m = float(input(\"Indiquer la cambrure du profil (entre 0 et 1): \"))\r\n        # p = float(input(\"Indiquer la position de la cambrure maximale du profil (entre 0 et 1): \"))\r\n        t = float(input(\"Indiquer l'épaisseur maximale du profil (entre 0 et 1): \"))\r\n        # c = float(input(\"Indiquer la longueur de corde du profil: \"))\r\n        # n_points = 18 #int(input(\"Indiquer le nombre de points souhaité pour le tracé du demi-profil: \"))\r\n\r\n        m = 0.04\r\n        p = 0.6\r\n        # t = 0.08\r\n        c = 1\r\n        n_points = 18\r\n\r\n        # Discrétisation le long de x (on utilise un espacement cosinus pour affiner vers le bord d'attaque)\r\n        beta = np.linspace(0.0, np.pi, n_points)\r\n        x = c * (0.5 * (1 - np.cos(beta)))\r\n\r\n        # Calcul de l'épaisseur relative yt(x)\r\n        yt = (t / 0.2) * c * (0.2969 * np.sqrt(x / c)\r\n                              - 0.1260 * (x / c)\r\n                              - 0.3516 * (x / c) ** 2\r\n                              + 0.2843 * (x / c) ** 3\r\n                              - 0.1015 * (x / c) ** 4)\r\n\r\n        # Calcul de la cambrure yc(x) et de dyc/dx\r\n        yc = np.zeros_like(x)\r\n        dyc_dx = np.zeros_like(x)\r\n        coordonnees = []\r\n        for i in range(len(x)):\r\n            xi = x[i] / c\r\n            if xi < p:  #Coordonnées profil sans cambrure\r\n                yc[i] = (m / p ** 2) * (2 * p * xi - xi ** 2) * c\r\n                dyc_dx[i] = (2 * m / p ** 2) * (p - xi)\r\n            else:   #Coordonnées profil après la cambrure\r\n                yc[i] = (m / (1 - p) ** 2) * (1 - 2 * p + 2 * p * xi - xi ** 2) * c\r\n                dyc_dx[i] = (2 * m / (1 - p) ** 2) * (p - xi)\r\n\r\n        # Calcul de theta(x)\r\n        theta = np.arctan(dyc_dx)\r\n\r\n        # Coordonnées des surfaces supérieure et inférieure\r\n        x_upper = x - yt * np.sin(theta)\r\n        y_upper = yc + yt * np.cos(theta)\r\n\r\n        x_lower = x + yt * np.sin(theta)\r\n        y_lower = yc - yt * np.cos(theta)\r\n\r\n        return x_upper, y_upper, x_lower, y_lower, x, c\r\n\r\n    #Fonction pour tracer le profil manuel\r\n    def tracer_profil_manuel(self, x_upper, y_upper, x_lower, y_lower):\r\n        plt.plot(x_upper, y_upper, marker='o', linewidth=1)\r\n        plt.plot(x_lower, y_lower, marker='o', linewidth=1)\r\n        plt.title(f\"Profil aérodynamique {self.nom}\")\r\n        plt.xlabel(\"x\")\r\n        plt.ylabel(\"y\")\r\n        plt.axis(\"equal\")  # pour que l’échelle soit respectée\r\n        plt.grid(True)\r\n        plt.show()\r\n\r\n    #Fonction pour enregistrer les données du profil manuel dans un fichier csv\r\n    def enregistrer_profil_manuel_csv(self, x_up, y_up, x_low, y_low, nom_fichier):\r\n        \"\"\"\r\n        Enregistre les coordonnées du profil et ses propriétés dans un fichier CSV.\r\n\r\n        Paramètres :\r\n            x_up, y_up : coordonnées du bord supérieur\r\n            x_low, y_low : coordonnées du bord inférieur\r\n            m, p, t, c : paramètres NACA\r\n            nom_fichier : nom du fichier de sortie\r\n        \"\"\"\r\n        with open(nom_fichier, mode='w', newline='') as file:\r\n            writer = csv.writer(file)\r\n\r\n            # Écriture des propriétés du profil\r\n            # writer.writerow([\"Nom:\", self.nom])\r\n            # writer.writerow([\"Cambrure (m):\", m])\r\n            # writer.writerow([\"Position de cambrure (p):\", p])\r\n            # writer.writerow([\"Epaisseur (t):\", t])\r\n            # writer.writerow([\"Longueur de corde (c):\", c])\r\n            # writer.writerow([])  # ligne vide\r\n            writer.writerow([\"x\", \"y_haut\", \"y_bas\"])\r\n\r\n            for i in range(len(x_up)):\r\n                writer.writerow([x_up[i], y_up[i], x_low[i], y_low[i]])  # supposant que x_up = x_low\r\n\r\n        print(f\"Les coordonnées du profil on été enregistré dans le fichier: {nom_fichier}\")\r\n\r\n    def enregistrer_profil_format_dat(self, x_up, y_up, x_low, y_low, c, nom_fichier):\r\n        \"\"\"\r\n        Enregistre le profil au format XFOIL / AirfoilTools (.dat).\r\n\r\n        - x normalisé entre 0 et 1\r\n        - Ordre : extrados de 1 → 0, puis intrados de 0 → 1\r\n        \"\"\"\r\n        with open(nom_fichier, mode='w') as file:\r\n            file.write(f\"{self.nom}\\n\")\r\n\r\n            # Extrados : de 1 vers 0\r\n            for i in reversed(range(len(x_up))):\r\n                x = x_up[i] / c\r\n                y = y_up[i] / c\r\n                file.write(f\"{x:.6f} {y:.6f}\\n\")\r\n\r\n            # Intrados : de 0 vers 1\r\n            for i in range(1, len(x_low)):\r\n                x = x_low[i] / c\r\n                y = y_low[i] / c\r\n                file.write(f\"{x:.6f} {y:.6f}\\n\")\r\n\r\n    \"\"\"\r\n        ---- Fin des fonctions de classe pour tracer un profil (Airfoil) manuellement ---\r\n    \"\"\"\r\n\r\n    def tracer_avec_bruit(self, amplitude=0.01, mode=\"gaussien\", zone=(0.0, 0.3)):\r\n        from math import isfinite\r\n        bruit = BruitProfil(amplitude=amplitude, mode=mode, zone=zone)\r\n        coord_bruitees = bruit.appliquer(self.coordonnees)\r\n\r\n        x0, y0 = zip(*self.coordonnees)\r\n        x1, y1 = zip(*coord_bruitees)\r\n\r\n        plt.figure(figsize=(8, 4))\r\n        plt.plot(x0, y0, label=\"Original\", linewidth=2)\r\n        plt.plot(x1, y1, '--', label=f\"Givré ({amplitude * 100:.1f} % corde)\", alpha=0.8)\r\n        plt.axis('equal')\r\n        plt.grid(True)\r\n        plt.legend()\r\n        plt.xlabel(\"x\")\r\n        plt.ylabel(\"y\")\r\n        plt.title(f\"{self.nom} — givrage zone {zone}\")\r\n        plt.show()\r\n\r\n    def tracer_avec_rotation(self, angle_deg=5, centre=(0, 0)):\r\n        from Airfoil import RotationProfil  # à enlever si déjà dans le fichier\r\n        rotation = RotationProfil(angle_deg=angle_deg, centre=centre)\r\n        coord_rot = rotation.appliquer(self.coordonnees)\r\n\r\n        x1, y1 = zip(*self.coordonnees)\r\n        x2, y2 = zip(*coord_rot)\r\n\r\n        plt.figure(figsize=(8, 4))\r\n        plt.plot(x1, y1, label=\"Profil original\", linewidth=2)\r\n        plt.plot(x2, y2, label=f\"Rotation {angle_deg}°\", linestyle=\"--\")\r\n        plt.title(f\"Profil {self.nom} : original vs tourné\")\r\n        plt.xlabel(\"x\")\r\n        plt.ylabel(\"y\")\r\n        plt.axis(\"equal\")\r\n        plt.grid(True)\r\n        plt.legend()\r\n        plt.show()\r\n\r\n    def tracer_vrillage(self, angle_max_deg=20):\r\n        from Airfoil import RotationVrillee\r\n        vrilleur = RotationVrillee(angle_max_deg=angle_max_deg)\r\n        coord_vrillees = vrilleur.appliquer(self.coordonnees)\r\n\r\n        x1, y1 = zip(*self.coordonnees)\r\n        x2, y2 = zip(*coord_vrillees)\r\n\r\n        plt.figure(figsize=(8, 4))\r\n        plt.plot(x1, y1, label=\"Profil original\", linewidth=2)\r\n        plt.plot(x2, y2, label=f\"Vrillage {angle_max_deg}°\", linestyle=\"--\")\r\n        plt.title(f\"Vrillage progressif du profil {self.nom}\")\r\n        plt.xlabel(\"x\")\r\n        plt.ylabel(\"y\")\r\n        plt.axis(\"equal\")\r\n        plt.grid(True)\r\n        plt.legend()\r\n        plt.show()\r\n\r\n\r\nclass RotationProfil:\r\n    def __init__(self, angle_deg=0, centre=(0, 0)):\r\n        self.angle_rad = np.radians(angle_deg)      #  conversion degrés = radians\r\n        self.centre = np.array(centre)              #  point autour duquel on tourne\r\n\r\n    def appliquer(self, coordonnees):\r\n        coords = np.array(coordonnees)              #  convertit liste de tuples = array Nx2\r\n        coords -= self.centre                        #  déplacement du centre vers l’origine (x - x0, y - y0)\r\n\r\n        M = np.array([                               #  Matrice de rotation\r\n            [np.cos(self.angle_rad), -np.sin(self.angle_rad)],\r\n            [np.sin(self.angle_rad),  np.cos(self.angle_rad)]\r\n        ])\r\n\r\n        rot = coords @ M.T                           #  produit matriciel : rotation\r\n        return (rot + self.centre).tolist()          #  on revient au repère initial (x + x0, y + y0)\r\n\r\n\r\n# Classe pour appliquer du bruit (rugosité, givrage, etc.) sur une région du profil\r\n\r\n\r\nclass BruitProfil:\r\n    def __init__(self, amplitude=0.01, mode=\"gaussien\", zone=(0.0, 0.3)):\r\n        \"\"\"\r\n        amplitude : déplacement max (en corde unité)\r\n        mode      : \"gaussien\" ou \"uniforme\"\r\n        zone      : (x_min, x_max) sur lequel on applique le bruit\r\n        \"\"\"\r\n        self.amplitude = amplitude\r\n        self.mode = mode\r\n        self.zone = zone\r\n\r\n    def appliquer(self, coordonnees):\r\n        # conversion et extraction\r\n        coords = np.array(coordonnees)       # shape (N,2)\r\n        x_vals, y_vals = coords[:,0], coords[:,1]\r\n\r\n        # calcul des tangentes et normales\r\n        dx_ds, dy_ds = np.gradient(x_vals), np.gradient(y_vals)\r\n        tangentes = np.vstack((dx_ds, dy_ds)).T\r\n        norms = np.linalg.norm(tangentes, axis=1)\r\n        normals = np.column_stack((-dy_ds/norms, dx_ds/norms))\r\n\r\n        # on ne bruit que là où x dans la zone ET y >= 0 (extrados)\r\n        masque = (\r\n            (x_vals >= self.zone[0])\r\n            & (x_vals <= self.zone[1])\r\n            & (y_vals >= 0)\r\n        )\r\n\r\n        # génération du bruit scalaire\r\n        if self.mode == \"gaussien\":\r\n            eta = np.random.normal(0, self.amplitude, size=len(x_vals))\r\n        else:\r\n            eta = np.random.uniform(-self.amplitude, self.amplitude, size=len(x_vals))\r\n\r\n        # on garde uniquement les eta pour lesquels masque=True\r\n        eta *= masque\r\n\r\n        # décalage suivant la normale\r\n        coords_bruitees = coords + normals * eta[:, None]\r\n\r\n        return [tuple(pt) for pt in coords_bruitees]\r\n\r\n\r\n           #  ajout du bruit point par point\r\n\r\n\r\nclass RotationVrillee:\r\n    def __init__(self, angle_max_deg=20, axe=\"x\", centre_y=0.0):\r\n        self.angle_max = np.radians(angle_max_deg)\r\n        self.axe = axe\r\n        self.centre_y = centre_y  # centre de rotation en y\r\n\r\n    def appliquer(self, coordonnees):\r\n        coords = np.array(coordonnees)\r\n        nouvelles_coords = []\r\n\r\n        for x, y in coords:\r\n            # Angle de rotation en fonction de x (linéaire)\r\n            alpha = self.angle_max * x\r\n\r\n            # Rotation autour de (x, centre_y)\r\n            dy = y - self.centre_y\r\n            y_rot = self.centre_y + dy * np.cos(alpha)\r\n\r\n            nouvelles_coords.append((x, y_rot))\r\n\r\n        return nouvelles_coords\r\n\r\ndef generer_pale_vrillee(profil_2d, angle_max_deg=30, z_max=1.0, sections=50):\r\n    pale = []\r\n    for i in range(sections):\r\n        z = z_max * i / (sections - 1)\r\n        angle_local = angle_max_deg * z / z_max  # rotation linéaire selon Z\r\n        rotation = RotationProfil(angle_deg=angle_local, centre=(0.25, 0))  # tu peux changer le centre\r\n        section = rotation.appliquer(profil_2d)\r\n        for x, y in section:\r\n            pale.append((x, y, z))\r\n    return np.array(pale)\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Airfoil.py b/Airfoil.py
--- a/Airfoil.py	(revision 3c2a52b422250630ee979b6c52291b3f09ca9e74)
+++ b/Airfoil.py	(date 1750015984763)
@@ -3,6 +3,10 @@
 import matplotlib.pyplot as plt
 import numpy as np
 import csv
+import os
+
+Dossier_data = "data/"
+os.makedirs(Dossier_data, exist_ok=True) # crée le dossier si il n'existe pas
 
 ## Class Airfoil va représenter un profil NACA avec ses cordonnées
 
@@ -39,11 +43,16 @@
 
     # Stocker les coordonnées de Airfoils
     def sauvegarder_coordonnees(self, nom_fichier="coordonnees.csv"):
+        nom_fichier = nom_fichier or f"{self.nom}_coordonnees.csv"
+        chemin= os.path.join(Dossier_data, nom_fichier)
+
         with open(nom_fichier, "w") as fichier:
             fichier.write("x,y\n")
             for x, y in self.coordonnees:
                 fichier.write(f"{x},{y}\n")
 
+        return chemin
+
     # Tracer le contour
     def tracer_contour(self, nom_profil):
         x_vals = [point[0] for point in self.coordonnees]
Index: aerodynamique.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nfrom io import StringIO\r\nfrom Airfoil import Airfoil\r\nimport subprocess\r\nimport os\r\n\r\nclass Aerodynamique:\r\n\r\n    def __init__(self, nom):\r\n        self.nom = nom  # ex: n2414-il\r\n        self.url_csv = f\"http://airfoiltools.com/polar/csv?polar=xf-{self.nom}-50000.csv\"\r\n       # xf - naca4412 - il - 50000.csv\r\n        self.donnees = None\r\n\r\n    def recuperer_donnees_csv(self):\r\n        response = requests.get(self.url_csv)\r\n        if response.status_code != 200:\r\n            raise Exception(f\"Erreur d'accès au fichier CSV : {self.url_csv}\")\r\n\r\n        lignes = [l for l in response.text.splitlines() if not l.startswith(\"#\")]\r\n        colonnes = [\"alpha\", \"Cl\", \"Cd\", \"Cdp\", \"Cm\", \"Top_Xtr\", \"Bot_Xtr\"]\r\n        self.donnees = pd.read_csv(StringIO(\"\\n\".join(lignes)), names=colonnes, skiprows=1)\r\n        print(\" Données CSV récupérées.\")\r\n\r\n    def sauvegarder_donnees(self, nom_fichier=\"polar_airfoil.csv\"):\r\n        if self.donnees is not None:\r\n            with open(nom_fichier, \"w\") as fichier:\r\n                fichier.write(\",\".join(self.donnees.columns) + \"\\n\")  # ligne d'en-tête\r\n                for _, ligne in self.donnees.iterrows():\r\n                    valeurs = \",\".join([str(val) for val in ligne])\r\n                    fichier.write(valeurs + \"\\n\")\r\n            print(f\" Données sauvegardées dans {nom_fichier}\")\r\n        else:\r\n            print(\" Aucune donnée à sauvegarder.\")\r\n\r\n    def tracer_depuis_csv(self, nom_fichier):\r\n        try:\r\n            # Lire le fichier brut ligne par ligne\r\n            with open(nom_fichier, \"r\", encoding=\"utf-8\") as f:\r\n                lignes = f.readlines()\r\n\r\n            # Trouver l'index de la vraie ligne d'en-tête (celle qui commence par Alpha ou alpha)\r\n            index_en_tete = -1\r\n            for i, ligne in enumerate(lignes):\r\n                if ligne.strip().lower().startswith(\"alpha\"):\r\n                    index_en_tete = i\r\n                    break\r\n\r\n            if index_en_tete == -1:\r\n                print(\" Ligne d'en-tête non trouvée.\")\r\n                return\r\n\r\n            # Lire dans pandas à partir de la bonne ligne\r\n            from io import StringIO\r\n            contenu_utilisable = \"\".join(lignes[index_en_tete:])\r\n            df = pd.read_csv(StringIO(contenu_utilisable))\r\n\r\n            # Nettoyage si besoin\r\n            df.columns = [c.strip().lower() for c in df.columns]  # ex: alpha, cl, cd, cm...\r\n            df = df.astype(float)\r\n\r\n            # Tracer\r\n            fig, axs = plt.subplots(3, 1, figsize=(10, 9), sharex=True)\r\n\r\n            axs[0].plot(df[\"alpha\"], df[\"cl\"], label=\"Cl\", color=\"blue\")\r\n            axs[0].set_ylabel(\"Cl\")\r\n            axs[0].legend()\r\n            axs[0].grid(True)\r\n\r\n            axs[1].plot(df[\"alpha\"], df[\"cd\"], label=\"Cd\", color=\"red\")\r\n            axs[1].set_ylabel(\"Cd\")\r\n            axs[1].legend()\r\n            axs[1].grid(True)\r\n\r\n            axs[2].plot(df[\"alpha\"], df[\"cm\"], label=\"Cm\", color=\"green\")\r\n            axs[2].set_xlabel(\"Angle d'attaque α (°)\")\r\n            axs[2].set_ylabel(\"Cm\")\r\n            axs[2].legend()\r\n            axs[2].grid(True)\r\n\r\n            fig.suptitle(f\"Polaires depuis : {nom_fichier}\")\r\n            plt.tight_layout()\r\n            plt.show()\r\n\r\n        except Exception as e:\r\n            print(f\" Erreur : {e}\")\r\n\r\n    def telecharger_et_sauvegarder_txt(self, nom_fichier=\"polar_airfoil.txt\"):\r\n\r\n        url_txt = f\"http://airfoiltools.com/polar/text?polar=xf-{self.nom}-50000.txt\"\r\n        #xf - naca4412 - il - 50000.txt\r\n        response = requests.get(url_txt)\r\n\r\n        if response.status_code != 200:\r\n            raise Exception(f\"Erreur d'accès au fichier TXT : {url_txt}\")\r\n\r\n        with open(nom_fichier, \"w\", encoding=\"utf-8\") as fichier:\r\n            fichier.write(response.text)\r\n\r\n        print(f\"Performances aérodynamiques enregistrés dans le fichier: {nom_fichier}\")\r\n\r\n    def lire_txt_et_convertir_dataframe(self, nom_fichier_txt):\r\n        lignes = []\r\n        commencer = False\r\n\r\n        with open(nom_fichier_txt, \"r\", encoding=\"utf-8\") as f:\r\n            for ligne in f:\r\n                ligne = ligne.strip()\r\n                if not ligne:\r\n                    continue  # ignorer les lignes vides\r\n                if ligne.lower().startswith(\"alpha\"):\r\n                    commencer = True\r\n                    lignes.append(ligne)\r\n                elif commencer:\r\n                    if all(c in \"- \" for c in ligne):\r\n                        continue  # ignorer ligne de séparation visuelle\r\n                    lignes.append(ligne)\r\n\r\n        # Transformation en DataFrame\r\n        colonnes = lignes[0].split()\r\n        data = [l.split() for l in lignes[1:]]\r\n\r\n        df = pd.DataFrame(data, columns=colonnes)\r\n        df = df.astype(float)\r\n        return df\r\n\r\n    def tracer_polaires_depuis_txt(self):\r\n        if self.donnees is None:\r\n            print(\"Aucune donnée à tracer.\")\r\n            return\r\n\r\n        fig, axes = plt.subplots(3, 1, figsize=(5, 7), sharex=True)  # 3 lignes, 1 colonne\r\n\r\n        # 1. Cl\r\n        axes[0].plot(self.donnees[\"alpha\"], self.donnees[\"CL\"], color=\"blue\")\r\n        axes[0].set_ylabel(\"Cl\")\r\n        axes[0].set_title(f\"Polaires du profil : {self.nom}\")\r\n        axes[0].grid(True)\r\n\r\n        # 2. Cd\r\n        axes[1].plot(self.donnees[\"alpha\"], self.donnees[\"CD\"], color=\"red\")\r\n        axes[1].set_ylabel(\"Cd\")\r\n        axes[1].grid(True)\r\n\r\n        # 3. Cm\r\n        axes[2].plot(self.donnees[\"alpha\"], self.donnees[\"CM\"], color=\"green\")\r\n        axes[2].set_ylabel(\"Cm\")\r\n        axes[2].set_xlabel(\"Angle d'attaque α (°)\")\r\n        axes[2].grid(True)\r\n\r\n        plt.tight_layout()\r\n        plt.show()\r\n\r\n    def run_xfoil(self, dat_file, reynolds, mach, alpha_start=-5, alpha_end=15, alpha_step=1, output_file=\"polar_output.txt\"):\r\n        xfoil_path = os.path.join(os.getcwd(), \"xfoil.exe\")\r\n\r\n        # Script pour XFOIL\r\n        xfoil_input = f\"\"\"\r\n    LOAD {dat_file}\r\n    PANE\r\n    OPER\r\n    VISC {reynolds}\r\n    MACH {mach}\r\n    ITER 100\r\n    PACC\r\n    {output_file}\r\n    \r\n    ASEQ {alpha_start} {alpha_end} {alpha_step}\r\n    QUIT\r\n    \"\"\"\r\n\r\n        try:\r\n            result = subprocess.run(\r\n                [xfoil_path],\r\n                input=xfoil_input.encode(),\r\n                stdout=subprocess.PIPE,\r\n                stderr=subprocess.PIPE,\r\n                cwd = os.getcwd() # Utilise le dossier actuel automatiquement\r\n            )\r\n            if result.returncode != 0:\r\n                print(\"Erreur XFOIL :\", result.stderr.decode())\r\n            else:\r\n                print(f\"Analyse XFOIL terminée. Résultats dans : {output_file}\")\r\n        except FileNotFoundError:\r\n            print(\"XFOIL introuvable. Vérifie le chemin ou l'existence de xfoil.exe.\")\r\n\r\n    def calculer_finesse(self, nom_fichier):\r\n\r\n        data = self.lire_txt_et_convertir_dataframe(nom_fichier)\r\n\r\n        finesse = (data[\"CL\"] / data[\"CD\"]).tolist()\r\n\r\n        finesse_max = max(finesse)\r\n\r\n        return finesse, finesse_max\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/aerodynamique.py b/aerodynamique.py
--- a/aerodynamique.py	(revision 3c2a52b422250630ee979b6c52291b3f09ca9e74)
+++ b/aerodynamique.py	(date 1750015984748)
@@ -6,6 +6,9 @@
 import subprocess
 import os
 
+Dossier_data = "data/"
+os.makedirs(Dossier_data, exist_ok=True) # crée le dossier si il n'existe pas
+
 class Aerodynamique:
 
     def __init__(self, nom):
@@ -96,11 +99,15 @@
         if response.status_code != 200:
             raise Exception(f"Erreur d'accès au fichier TXT : {url_txt}")
 
+        chemin = os.path.join(Dossier_data, nom_fichier)
+
         with open(nom_fichier, "w", encoding="utf-8") as fichier:
             fichier.write(response.text)
 
         print(f"Performances aérodynamiques enregistrés dans le fichier: {nom_fichier}")
 
+        return chemin
+
     def lire_txt_et_convertir_dataframe(self, nom_fichier_txt):
         lignes = []
         commencer = False
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Airfoil import *\r\nfrom aerodynamique import *\r\nfrom ConditionVol import *\r\nfrom gestion_base import *\r\n\r\n# profil = Airfoil.depuis_airfoiltools(\"naca2412-il\")\r\n# pourcentage = float(input(\"Pourcentage de bruit (%): \"))\r\n# profil.tracer_avec_bruit(pourcentage_bruit=pourcentage)\r\n\r\n# nom_profil = input(\"Nom du profil (ex: naca2412-il): \")\r\n# profil = Airfoil.depuis_airfoiltools(nom_profil)\r\n#\r\n# angle = float(input(\"Angle de rotation (°): \"))\r\n# profil.tracer_avec_rotation(angle_deg=angle)\r\n\r\n\r\n# nom_profil = input(\"Entrez le nom du profil (ex: naca2412-il): \")\r\n# profil = Airfoil.depuis_airfoiltools(nom_profil)\r\n\r\n# angle_max = float(input(\"Angle maximal de vrillage au bord de fuite (en degrés) : \"))\r\n# profil.tracer_vrillage(angle_max_deg=angle_max)\r\n#\r\n# profil = Airfoil.depuis_airfoiltools(\"naca4412-il\")\r\n# coords = np.array(profil.coordonnees)\r\n#\r\n# pale = generer_pale_vrillee(coords, angle_max_deg=45, z_max=1.0)\r\n#\r\n# fig = plt.figure()\r\n# ax = fig.add_subplot(111, projection='3d')\r\n# ax.plot(pale[:, 0], pale[:, 1], pale[:, 2])\r\n# plt.title(\"Pale vrillée (rotation selon Z)\")\r\n# plt.show()\r\n\r\n\r\n# profil = Airfoil.depuis_airfoiltools(\"naca2412-il\")\r\n# aero = Aerodynamique(profil)\r\n\r\n# Étape 2 : Créer l’objet aérodynamique à partir du profil\r\n# aero = Aerodynamique(profil)\r\n\r\n# Étape 3 : Récupérer les données depuis AirfoilTools\r\n# aero.recuperer_donnees()\r\n\r\n# Étape 4 : Sauvegarder dans un fichier CSV\r\n# aero.sauvegarder_csv(\"polaire_naca2412.csv\")\r\n\r\n# Étape 5 : Tracer les courbes Cl, Cd, Cm\r\n# aero.tracer_polaires()\r\n###############################################################\r\nimport asyncio\r\nfrom VolOpenSkyAsync import VolOpenSkyAsync\r\nfrom VolOpenSkyAsync import charger_compagnies_depuis_csv\r\n\r\n# # Charger les compagnies\r\n# compagnies = charger_compagnies_depuis_csv(\"data/iata_airlines.csv\")\r\n#\r\n# async def main():\r\n#     api = VolOpenSkyAsync()\r\n#     vols = await api.get_vols(limit=3)\r\n#\r\n#     for i, v in enumerate(vols):\r\n#         code = v['callsign'][:3].upper().strip()\r\n#         print(f\" Recherche du code : {code}\")\r\n#\r\n#         nom, pays = compagnies.get(code, (\"Compagnie inconnue\", \"Pays inconnu\"))\r\n#\r\n#         if (nom, pays) == (\"Compagnie inconnue\", \"Pays inconnu\"):\r\n#             print(f\" Code {code} non trouvé dans le fichier.\")\r\n#\r\n#         print(f\"{i+1}.  {v['callsign']} - {nom} ({pays})\")\r\n#         print(f\"   Altitude: {v['altitude_m']:.1f} m - Vitesse: {v['vitesse_mps']:.1f} m/s\")\r\n#         lat, lon = v[\"position\"]\r\n#         alt = v[\"altitude_m\"]\r\n#         delta = get_delta_isa(lat, lon, alt, API_KEY)\r\n#\r\n#         # Met à jour le delta ISA dans ton objet\r\n#         v[\"condition_vol\"].delta_isa = delta\r\n#         # Affiche tous les paramètres aérodynamiques\r\n#         v[\"condition_vol\"].afficher()\r\n#         print()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    API_KEY = \"c6bf5947268d141c6ca08f54c7d65b63\"\r\n\r\n    #Initialisation de la basse de données des profils\r\n    gestion = GestionBase()\r\n\r\n    print(\"\\n---- Début du programme Airfoil ----\\n\")\r\n\r\n    #On demande à l'utilisateur s'il veut créer ou importer un profil\r\n    while True:\r\n        generation = input(\"Voulez-vous importer ou générer un profil d'aile? \").strip().lower()\r\n        if generation in [\"importer\", \"générer\"]:\r\n            break  # OK : on sort de la boucle\r\n        else:\r\n            print(\"Réponse invalide. Veuillez taper 'importer' ou 'générer'.\\n\")\r\n\r\n    \"\"\"\r\n            ---DANS LE CAS D'UNE IMPORTATION\r\n    \"\"\"\r\n\r\n    if generation == \"importer\":\r\n\r\n        nom_profil = input(\"\\nEntrez le nom exact du profil NACA : (format : naca2412) : \").strip().lower()\r\n        nom_profil = f\"{nom_profil}-il\"\r\n\r\n        # Récupération du profil et Sauvegarde des coordonnées\r\n        profil = Airfoil.depuis_airfoiltools(nom_profil)\r\n        profil.sauvegarder_coordonnees(f\"{nom_profil}_coord_profil.csv\")\r\n\r\n        print(f\"\\nLes coordonnées du profil ont été enregistrés dans le fichier: {nom_profil}_coord_profil.csv\")\r\n\r\n        tracer = input(\"\\nVoulez-vous afficher le profil? (Oui / Non): \").strip().lower()\r\n\r\n        if tracer == \"oui\":\r\n            # Affichage graphique\r\n            profil.tracer_contour(nom_profil)\r\n        elif tracer == \"non\":\r\n            pass\r\n        else:\r\n            pass\r\n\r\n        recup_coef_aero = input(\"\\nVoulez-vous récupérer les performances aérodynamiques de votre profil? (Oui / Non): \").strip().lower()\r\n\r\n        if recup_coef_aero == \"oui\":\r\n\r\n            aero = Aerodynamique(nom_profil)\r\n\r\n            # Télécharger le fichier texte depuis AirfoilTools\r\n            nom_fichier_txt = f\"polar_{nom_profil}.txt\"\r\n            aero.telecharger_et_sauvegarder_txt(nom_fichier_txt)\r\n\r\n            # Lire le fichier texte et convertir en DataFrame\r\n            df = aero.lire_txt_et_convertir_dataframe(nom_fichier_txt)\r\n\r\n            # Stocker dans l’objet et tracer\r\n            aero.donnees = df\r\n            aero.tracer_polaires_depuis_txt()\r\n\r\n            perfo_pour_finesse = \"importer\"\r\n\r\n        elif recup_coef_aero == \"non\":\r\n            pass\r\n\r\n        else:\r\n            pass\r\n\r\n            # chemins des fichiers des fichiers crées\r\n            chemin_csv = f\"{nom_profil}_coord_profil.csv\"\r\n            chemin_dat = None  # pas utile dans le cas du profil importé\r\n            chemin_txt = f\"polar_{nom_profil}.txt\" if recup_coef_aero == \"oui\" else None\r\n            chemin_pol_csv = None\r\n\r\n            # on enregistre le profil dans la base et on deplace les fichiers\r\n            gestion.ajouter_profil(\r\n                nom_profil,\r\n                \"importé\",\r\n                chemin_csv,\r\n                None,\r\n                chemin_txt,\r\n                None\r\n\r\n            )\r\n\r\n        \"\"\"\r\n            ---DANS LE CAS D'UNE CRÉATION MANUELLE\r\n        \"\"\"\r\n\r\n    elif generation == \"générer\":\r\n\r\n        # Création d'un profil manuel:\r\n        while True:\r\n            #demande un nom au fichier/profil\r\n            nom_profil_manuel = input(\"\\nEntrez le nom de votre profil NACA: \").strip().lower()\r\n            #Boucle pour vérifier si le fichier existe dèjà\r\n            verif_fichier = f\"{nom_profil_manuel}_coord_profil.csv\"\r\n\r\n            if os.path.exists(verif_fichier):\r\n                print(f\"Le fichier '{verif_fichier}' existe déjà.\")\r\n                choix = input(\"\\nVoulez-vous écraser le fichier ? (Oui/Non) : \").strip().lower()\r\n\r\n                if choix == \"oui\":\r\n                    print(f\"Suppression du fichier '{verif_fichier}'...\")\r\n                    os.remove(f\"{verif_fichier}\")\r\n                    break  # On sort de la boucle, on continue avec ce nom\r\n                elif choix == \"non\":\r\n                    print(\"\\nVeuillez entrer un autre nom de profil.\")\r\n            else:\r\n                break\r\n\r\n        profil_manuel = Airfoil(nom_profil_manuel, [])\r\n        x_up, y_up, x_low, y_low, x, c = profil_manuel.naca4_profil()\r\n\r\n        profil_manuel.enregistrer_profil_manuel_csv(x_up, y_up, x_low, y_low, nom_fichier=f\"{nom_profil_manuel}_coord_profil.csv\")\r\n        profil_manuel.enregistrer_profil_format_dat(x_up, y_up, x_low, y_low, c, nom_fichier=f\"{nom_profil_manuel}_coord_profil.dat\")\r\n\r\n        tracer = input(\"\\nVoulez-vous afficher le profil? (Oui / Non): \").strip().lower()\r\n\r\n        if tracer == \"oui\":\r\n            profil_manuel.tracer_profil_manuel(x_up, y_up, x_low, y_low)\r\n\r\n        elif tracer == \"non\":\r\n            pass\r\n        else:\r\n            pass\r\n\r\n        lancement_xfoil = input(\"\\nVoulez-vous calculer les performances de votre profil? (Oui / Non): \").strip().lower()\r\n\r\n        if lancement_xfoil == \"oui\":\r\n            aero = Aerodynamique(nom_profil_manuel)\r\n\r\n            mach = float(input(\"\\nRentrez une valeur de Mach (0 à 0.7): \"))\r\n            reynolds = int(input(\"\\nRentrez un nombre de Reynolds: \"))\r\n\r\n            # Générer la polaire avec XFOIL\r\n            aero.run_xfoil(f\"{nom_profil_manuel}_coord_profil.dat\", reynolds, mach, alpha_start=-5, alpha_end=15, alpha_step=1, output_file=f\"{nom_profil_manuel}_coef_aero.txt\")\r\n            coef_aero_generes = f\"{nom_profil_manuel}_coef_aero.txt\"\r\n            data = aero.lire_txt_et_convertir_dataframe(coef_aero_generes)\r\n            aero.donnees = data\r\n            aero.tracer_polaires_depuis_txt()\r\n\r\n            perfo_pour_finesse = \"générer\"\r\n\r\n        elif lancement_xfoil == \"non\":\r\n            pass\r\n\r\n        else:\r\n            pass\r\n\r\n        # chemins des fichiers des fichiers crées\r\n\r\n        chemin_csv = f\"{nom_profil_manuel}_coord_profil.csv\"\r\n        chemin_dat = f\"{nom_profil_manuel}_coord_profil.dat\"\r\n        chemin_txt = f\"{nom_profil_manuel}_coef_aero.txt\" if lancement_xfoil == \"oui\" else None\r\n        chemin_pol_csv = None\r\n\r\n        # on enregistre le profil dans la base et on deplace les fichiers\r\n        gestion.ajouter_profil(nom_profil_manuel, \"manuel\",\r\n                               chemin_csv, chemin_dat, chemin_txt, chemin_pol_csv)\r\n\r\n    calcul_finesse = input(\"\\nVoulez-vous calculer la finesse maximale? (Oui / Non): \").strip().lower()\r\n\r\n    if calcul_finesse == \"oui\":\r\n        if perfo_pour_finesse == \"générer\":\r\n            finesse, finesse_max = aero.calculer_finesse(f\"{nom_profil_manuel}_coef_aero.txt\")\r\n\r\n        elif perfo_pour_finesse == \"importer\":\r\n            finesse, finesse_max = aero.calculer_finesse(f\"polar_{nom_profil}.txt\")\r\n\r\n        print(f\"\\nLa finesse maximale de votre profil est : {finesse_max}\")\r\n\r\n    elif calcul_finesse == \"non\":\r\n        pass\r\n\r\n    else:\r\n        pass\r\n\r\n\r\n    \"\"\"\r\n        CHOISIR UN VOL EXISTANT:\r\n    \"\"\"\r\n    obtenir_condition_vol = input(\"\\nVoulez-vous obtenir choisir un vol existant: \").strip().lower()\r\n\r\n    if obtenir_condition_vol == \"oui\":\r\n        pass\r\n    elif obtenir_condition_vol == \"non\":\r\n        pass\r\n    else:\r\n        pass\r\n\r\n    \"\"\"\r\n        CONDITION DE VOL\r\n    \"\"\"\r\n\r\n    obtenir_conditions_vol = input(\"\\nVoulez-vous obtenir les conditions de vol: \").strip().lower()\r\n\r\n    if obtenir_condition_vol == \"oui\":\r\n\r\n        altitude = int(input(\"\\nAltitude (en mètres):\"))\r\n        mach = float(input(\"Nombre de mach:\"))\r\n        angle = int(input(\"Angle d'attaque (en °):\"))\r\n\r\n        conditions_vol = ConditionVol(altitude, mach, angle)\r\n        conditions_vol.afficher()\r\n\r\n    elif obtenir_condition_vol == \"non\":\r\n        pass\r\n\r\n\r\n    print(\"\\n---- Fin du programme ----\\n\")\r\n\r\n    # nom = input(\"Nom du profil (ex: n2414-il) : \").strip()\r\n    # aero = Aerodynamique(nom)\r\n    #\r\n    # # Télécharger le fichier texte depuis AirfoilTools\r\n    # nom_fichier_txt = f\"polar_{nom}.txt\"\r\n    # aero.telecharger_et_sauvegarder_txt(nom_fichier_txt)\r\n    #\r\n    # # Lire le fichier texte et convertir en DataFrame\r\n    # df = aero.lire_txt_et_convertir_dataframe(nom_fichier_txt)\r\n    #\r\n    # # Stocker dans l’objet et tracer\r\n    # aero.donnees = df\r\n    # aero.tracer_polaires_depuis_txt()\r\n    # # Lina branchel\r\n    #\r\n    # \"\"\" def recuperer_donnees(self):\r\n    #         response = requests.get(self.url_csv)\r\n    #         if response.status_code != 200:\r\n    #             print(\"Erreur de récupération\")\r\n    #             return\"\"\"\r\n    #\r\n    # \"\"\"\r\n    #     lancement de Xfoil pour calculer les polaires\r\n    # \"\"\"\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 3c2a52b422250630ee979b6c52291b3f09ca9e74)
+++ b/main.py	(date 1750016001622)
@@ -108,7 +108,7 @@
 
         # Récupération du profil et Sauvegarde des coordonnées
         profil = Airfoil.depuis_airfoiltools(nom_profil)
-        profil.sauvegarder_coordonnees(f"{nom_profil}_coord_profil.csv")
+        chemin_csv = profil.sauvegarder_coordonnees() # on récupere le chemin depuis airfoil
 
         print(f"\nLes coordonnées du profil ont été enregistrés dans le fichier: {nom_profil}_coord_profil.csv")
 
@@ -130,7 +130,7 @@
 
             # Télécharger le fichier texte depuis AirfoilTools
             nom_fichier_txt = f"polar_{nom_profil}.txt"
-            aero.telecharger_et_sauvegarder_txt(nom_fichier_txt)
+            chemin_txt = aero.telecharger_et_sauvegarder_txt(nom_fichier_txt)
 
             # Lire le fichier texte et convertir en DataFrame
             df = aero.lire_txt_et_convertir_dataframe(nom_fichier_txt)
